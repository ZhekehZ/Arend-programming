\import Data.Bool (Bool, false, true)
\import Function.Meta ($)
\import Logic.Meta
\import Meta
\import Paths.Meta
\import Set
\import Set.Fin
\import Utils
\import lect04 (true/=false)
\import lect11 (funExt)
\import lect12 (DecEq, equivalence=>equality, exists)
\import lect13
\import lect14

-- 1. Докажите, что add x (add x s) = add x s и add x (add y s) = add y (add x s)

\func add-idemp {S : SetSpec} (x : S.A) (s : S) : add x (add x s) = add x s
  => S.setExt (add x (add x s)) (add x s) (\lam x1 =>
      (\lam ise => \case S.addProp x1 x (add x s) ise \with {
        | byLeft a => rewrite a (S.addHead x s)
        | byRight b => b
      }, S.addTail x1 x (add x s)))

\func add-swap {S : SetSpec} (x y : S.A) (s : S) : add x (add y s) = add y (add x s)
  => S.setExt (add x (add y s)) (add y (add x s)) (\lam x1 => (aux _ _ _ _, aux _ _ _ _))
  \where {
    \func aux {S : SetSpec} (x y x1 : S.A) (s : S) (ise : isElem x1 (add y (add x s))): isElem x1 (add x (add y s))
      => \case S.addProp _ _ (add x s) ise \with {
            | byLeft a => rewrite a (S.addTail _ _ _ (S.addHead _ _))
            | byRight b => \case S.addProp _ _ _ b \with {
              | byLeft a => rewrite a (S.addHead _ _)
              | byRight b1 => S.addTail _ _ _ (addTail _ _ _ b1)
            }
          }
  }

-- 2. Докажите, что множество подмножеств является инстансом SetSpec

\func subsets {A : \Set} : SetSpec {A} (A -> \Prop)
  => \new SetSpec {
      | empty => \lam a => Empty
      | add => \lam head subs a => (a = head) `Or` (subs a)
      | isElem => \lam a subs => subs a
      | setExt => \lam subs1 subs2 p => funExt (\lam a => \Prop) subs1 subs2
          (\lam a => \let q => p a \in path (iso q.1 q.2 (\lam a => Path.inProp _ _) (\lam a => Path.inProp _ _)))
      | emptySpec => \lam x e => e
      | addHead => \lam x s => byLeft idp
      | addTail => \lam y x s s1 => byRight s1
      | addProp => \lam y x s o => o
    }


-- 3. Докажите, что множество подмножеств является наибольшим инстансом, то есть любой другой вкладывается в него.

\func subsets-largest (S : SetSpec) : \Sigma (f : S -> (S.A -> \Prop)) (isInj f)
  => (\lam s a => isElem a s, \lam x y p =>
      S.setExt x y (\lam x1 => rewrite (pmap (\lam f => f x1) p) (\lam x => x, \lam x => x)))

-- 4. Определите функцию isEmpty для произвольного конечного множества и для ListSet.

\func isEmptySet {S : FinSetSpec} (x : S) : Bool => isEmptyListSet (rewrite listSet=Set x)

\func isEmptyListSet {A : \Set} (x : ListSet A) : Bool \elim x
  | inR nil => true
  | inR (cons a a1) => false
  | eq nil nil r i => true
  | eq nil (cons a a') r i => (absurd (aux' r) : true = false) @ i
  | eq (cons a a1) nil r i => (absurd (aux r) : false = true) @ i
  | eq (cons a a1) (cons a2 a') r i => false
  \where {
    \func aux {A : \Set} {a : A} {lst : List A} (p : EqList (cons a lst) nil): Empty
      => \let | t' => (p a).1 (here idp) \in contradiction

    \func aux' {A : \Set} {a : A} {lst : List A} (p : EqList nil (cons a lst)): Empty
      => \let | t' => (p a).2 (here idp) \in contradiction
  }

-- 5. Определите функцию union {A : \Set} : S A -> S A -> S A для
--        произвольного S A (удовлетворяющего FinSetSpec) и для ListSet.

\func union {S : FinSetSpec} (s1 s2 : S) : S =>
            rewriteI listSet=Set (unionListSet (rewrite listSet=Set s1) (rewrite listSet=Set s2))

\func unionListSet {A : \Set} (s1 s2 : ListSet A) : ListSet A
  | inR a, inR b => inR (a ++ b)
  | eq s1 s2 r i, inR a => lemma3 _ _ (lemma4 a r) @ i
  | inR a, eq s1 s2 r i => lemma3 _ _ (lemma4' a r) @ i
  \where {
    \func \infixl 5 ++ {A : \Set} (a b : List A): List A
      | nil, x => x
      | x, nil => x
      | cons a a1, cons a2 b => cons a $ cons a2 $ a1 ++ b

    \func lemma1 {A : \Set} {a : A} {l1 l2 : List A} (p : a `In (l1 ++ l2)): In a l1 `Or` In a l2 \elim l1, l2, p
      | nil, cons a1 l2, p => byRight p
      | cons a1 l1, nil, p => byLeft p
      | cons a1 l1, cons a2 l2, here idp => byLeft (here idp)
      | cons a1 l1, cons a2 l2, there p => \case \elim p \with {
        | here p => byRight (here p)
        | there p => \case lemma1 p \with {
          | byLeft a => byLeft (there a)
          | byRight b => byRight (there b)
        }
      }

    \func lemma2 {A : \Set} {a : A} (l1 l2 : List A) (p : In a l1): a `In (l1 ++ l2)
      | cons a1 l1, nil, p => p
      | cons a1 l1, cons a2 l2, here idp => here idp
      | cons a1 l1, cons a2 l2, there p => there (there (lemma2 l1 l2 p))

    \func lemma2' {A : \Set} {a : A} (l1 l2 : List A) (p : In a l2): a `In (l1 ++ l2)
      | nil, cons a1 l2, p => p
      | cons a1 l1, cons a2 l2, here idp => there (here idp)
      | cons a1 l1, cons a2 l2, there p => there (there (lemma2' l1 l2 p))

    \func lemma3 {A : \Set} (l1 l2 : List A) (p : EqList l1 l2): inR {List A} {EqList} l1 = inR l2
      => quotientEq l1 l2 p

    \func lemma4 {A : \Set} (l : List A) {l1 l2 : List A} (p : EqList l1 l2): EqList (l1 ++ l) (l2 ++ l)
      => \lam x => (
        \lam i => \case lemma1 i \with {
          | byLeft a1 => lemma2 _ _ ((p x).1 a1)
          | byRight b => lemma2' _ _ b
        },
        \lam i => \case lemma1 i \with {
          | byLeft a1 => lemma2 _ _ ((p x).2 a1)
          | byRight b => lemma2' _ _ b
        })

    \func lemma4' {A : \Set} (l : List A) {l1 l2 : List A} (p : EqList l1 l2): EqList (l ++ l1) (l ++ l2)
      => \lam x => (
        \lam i => \case lemma1 i \with {
          | byLeft a1 => lemma2 _ _ a1
          | byRight b => lemma2' _ _ ((p x).1 b)
        },
        \lam i => \case lemma1 i \with {
          | byLeft a1 => lemma2 _ _ a1
          | byRight b => lemma2' _ _ ((p x).2 b)
        })
  }

-- 6. Определите функцию intersection {A : DecSet} : S A -> S A -> S A для произвольного S A
--      (удовлетворяющего FinSetSpec) и для ListSet.

--\func intersection {S : FinSetSpec} {A : DecSet} (s1 s2 : S) : S =>
--  rewriteI listSet=Set (intersectionListSet (rewrite listSet=Set s1) (rewrite listSet=Set s2))


\func intersectionListSet {A : DecSet} (s1 s2 : ListSet A) : ListSet A \elim s1, s2
  | inR a, inR a1 => {?}
  | inR a, eq a1 a' r i => {?}
  | eq a a' r i, inR a1 => {?}
  \where { }

-- 7. Мы не можем определить функция size в общем случае, но мы можем определить предикат S -> Nat -> \Prop,
--        соответствующий \lam xs n => size xs <= n.
--    Задайте этот предикат и докажите, что он эквивалентен обычному определению, если A -- разрешимо и S -- конечно.

\func set-size-lt {S : SetSpec} (s : S) (n : Nat) => exists (\Sigma (x : S.A) (isElem x s) -> Fin n) isInj

-- Optional
-- 8. Определите предикат isFin : \Type -> \Prop так, чтобы множество
--    \Sigma (P : A -> \Prop) (isFin (\Sigma (a : A) (P A))) удовлетворяло FinSetSpec, определите этот инстанс.

-- Optional
-- 9. Определите NubListSet и инстанс FinSetSpec для него.
